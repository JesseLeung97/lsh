use crate::config::Config;
use crate::lsh::{HyperplaneCollection, HyperplaneSet, LSH };
/// A structure to describe user data in a transformed state.
/// 
/// **user_id**: the exact user ID used in the user database
/// 
/// **vector**: contains the original user data mapped to the range 0..1
/// 
/// **hashcode_set**: an array of generated hashcodes corresponding to the hash tables generated by LSH
pub struct Vector {
    user_id: u32,
    vector: Vec<f32>,
    hashcode_set: Vec<u32>
}

impl Vector {
    pub fn get(&self) -> &Vec<f32> {
        &self.vector
    }
    
    fn vector_to_u32(boolean_vector: &Vec<bool>) -> u32 {
        boolean_vector.iter().fold(0, |acc: u32, elem| (acc * 10 + if *elem { 1 } else { 0 }) as u32)
    }
    
    fn generate_hashcode(vector: &Vec<f32>, hyperplane_set : &HyperplaneSet) -> u32 {
        let boolean_vector: Vec<bool> = (0..hyperplane_set.set.len())
            .map(|i| LSH::normalize_dot_product(LSH::dot_product(vector, &hyperplane_set.set[i].vector)))
            .collect();
        Self::vector_to_u32(&boolean_vector)
    }
    
    fn generate_hashcode_set(vector: &Vec<f32>, hyperplane_collection: &HyperplaneCollection) -> Vec<u32> {
        let hashcode_vector: Vec<u32> = (0..hyperplane_collection.collection.len())
            .map(|i| Self::generate_hashcode(vector, &hyperplane_collection.collection[i]))
            .collect();
        hashcode_vector
    }
    
    pub fn new(user_id: u32, vector: Vec<f32>, hyperplane_collection: &HyperplaneCollection) -> Vector {
        let hashcode_set = Self::generate_hashcode_set(&vector, hyperplane_collection);
        Vector { user_id, vector, hashcode_set }
    }
}

#[cfg(test)]
mod tests {
    use test_case::test_case;
    use super::*;
    
    #[test_case(1010101, vec![true, false, true, false, true, false, true])]
    #[test_case(1111111, vec![true, true, true, true, true, true, true])]
    fn vector_to_u32_test_equal(test_num: u32, test_vec: Vec<bool>) {
        let actual = Vector::vector_to_u32(&test_vec);
        assert_eq!(test_num, actual);
    }

    #[test_case(0000000, vec![true, false, true, false, true, false, true])]
    #[test_case(1010101, vec![true, true, true, true, true, false, true])]
    fn vector_to_u32_test_not_equal(test_num: u32, test_vec: Vec<bool>) {
        let actual = Vector::vector_to_u32(&test_vec);
        assert_ne!(test_num, actual);
    }
}

